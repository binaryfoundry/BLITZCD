@DATABASE SYSTEM1
@Author Conversion program
@NODE OVERVIEW "Overview of SYSTEM1"

                                  @{b}@{u}Overview@{ub}@{uu}


                          An Acid Software Library

                         Converted to AmigaGuide by

                            Red When Excited Ltd

                 Used with the permission of Acid Software



@ENDNODE OVERVIEW

@NODE NEWTYPE "SYSTEM1"

@{fg shine}Statement: NEWTYPE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : NEWTYPE .Typename

NEWTYPE is used to create a custom variable type. NEWTYPE must be followed 
by a list of entry names separated by colons (':') and/or newlines. NEWTYPEs 
are terminated using End NEWTYPE.
Please refer to the Programming chapter of the Blitz 2 Programmers Guide for 
more information on setting up and using custom variable types.


@ENDNODE NEWTYPE

@NODE End "SYSTEM1"

@{fg shine}Statement: End@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : End [If|While|Select|Statement|Function|SetInt|SetErr|NEWTYPE|Macro]

End will halt program flow completely. In the case of programs run from the 
Blitz 2 editor, you will be returned to the editor. In the case of 
executable files, you will be returned to the Workbench or CLI.

End is often also useful to prevent program flow from running into a 
subroutine.


@ENDNODE End

@NODE Let "SYSTEM1"

@{fg shine}Statement: Let@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Let Var=|Operator Expression


@ENDNODE Let

@NODE Dim "SYSTEM1"

@{fg shine}Statement: Dim@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Dim Arrayname [List] (Dimension1[,Dimension2..])

Dim is used to initialize a BASIC array. Blitz 2 supports 2 array types - 
simple arrays, and list arrays. The optional List parameter, if present, 
denotes a list array. Simple arrays are identical to standard BASIC arrays, 
and may be of any number dimensions. List arrays may be of only 1 dimension.

Lists are covered fully in the Blitz 2 programmers guide, under the 
programming section.


@ENDNODE Dim

@NODE Goto "SYSTEM1"

@{fg shine}Statement: Goto@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Goto Program Label

Goto causes program flow to be transferred to the specified program label. 
This allows sections of a program to be 'skipped' or 'repeated'.


@ENDNODE Goto

@NODE Gosub "SYSTEM1"

@{fg shine}Statement: Gosub@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Gosub Program Label

Gosub operates in two steps. First, the location of the instruction 
following the Gosub is remembered in a special storage area (known as the 
'stack'). Secondly, program flow is transferred to the specified Program 
Label.

The section of program that program flow is transferred to is known as a 
'subroutine' and is usually terminated by a Return command. The Return 
command has the effect of returning program flow to the location remembered 
by the previous Gosub command. 

This allows a section of a program to be used by many other parts of the 
same program.


@ENDNODE Gosub

@NODE Return "SYSTEM1"

@{fg shine}Statement: Return@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Return 

Return is used to return program flow to the instruction following the 
previously executed Gosub command. This allows the creation of 'subroutines' 
which may be called from various points in a program.


@ENDNODE Return

@NODE Statement "SYSTEM1"

@{fg shine}Statement: Statement@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Statement Procedurename{[Parameter1[,Parameter2...]]}

Statement declares all following code up to the next End Statement as being 
a 'statement type' procedure.

Up to 6 Parameters may be passed to a statement in the form of local 
variables through which calling parameters are passed.

In Blitz 2, all statements and functions must be declared before they are 
called.


Statement: Function
--------------------------------------------------------------------------------
Modes  : 
Syntax : Function [.Type] Procedurename{[Parameter1[,Parameter2...]]}

Function declares all following code up to the next End Function as being a 
function type procedure.
The optional Type parameter may be used to determine what type of result is 
returned by the function. Type, if specified, must be one Blitz 2's 6 
primitive variable types. If no Type is given, the current default type is 
used.

Up to 6 Parameters may be passed to a function in the form of local 
variables through which calling parameters are passed.

Functions may return values through the Function Return command.

In Blitz 2, all statements and functions must be declared before they are 
called.


@ENDNODE Statement

@NODE MouseWait "SYSTEM1"

@{fg shine}Statement: MouseWait@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : MouseWait 

MouseWait simply halts program flow until the left mouse button is pushed. 
If the left mouse button is already held down when a MouseWait is executed, 
program flow will simply continue through.

This is often useful in Blitz 2 to prevent a program from terminating too 
quickly and leaving you back in the editor.

MouseWait should normally be used only for program testing purposes, as 
MouseWait severely slows down multi-tasking.


@ENDNODE MouseWait

@NODE If "SYSTEM1"

@{fg shine}Statement: If@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : If Expression [Then...]



@ENDNODE If

@NODE While "SYSTEM1"

@{fg shine}Statement: While@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : While Expression

The While command is used to execute a series of commands repeatedly while 
the specified Expression proves to be true. The commands to be executed 
include all the commands following the While until the next matching Wend.


@ENDNODE While

@NODE Macro "SYSTEM1"

@{fg shine}Statement: Macro@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Macro Macroname

Macro is used to declare the start of a macro definition. All text following 
Macro, up until the next End Macro, will be included in the macro's 
contents.

Please refer to the Programming chapter of the Blitz 2 Programmers Guide for 
more information on macros.


@ENDNODE Macro

@NODE Select "SYSTEM1"

@{fg shine}Statement: Select@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Select Expression

Select Expression
Case 1
;execute this if expression evaluated to 1
Case 2
;execute this if expression evaluated to 2
.
.may have many more 'Case's...
.
Default
;execute this if expression did not match any of the cases.
End Select


@ENDNODE Select

@NODE Case "SYSTEM1"

@{fg shine}Statement: Case@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Case Expression

A Case is used following a Select to execute a section of program code when, 
and only when, the Expression specified in the Case statement is equivalent 
to the Expression specified in the Select statement.

If a Case statement is satisfied, program flow will continue until the next 
Case, Default or End Select statement is encountered, at which point program 
flow will branch to the next matching End Select.


@ENDNODE Case

@NODE Default "SYSTEM1"

@{fg shine}Statement: Default@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Default 

A Default statement may appear following a series of Case statements to 
cause a section of program code to be executed if NONE of the Case 
statements were satisfied.


@ENDNODE Default

@NODE AsmExit "SYSTEM1"

@{fg shine}Statement: AsmExit@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : AsmExit 



@ENDNODE AsmExit

@NODE XINCLUDE "SYSTEM1"

@{fg shine}Statement: XINCLUDE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : XINCLUDE Filename

XINCLUDE stands for exclusive include. XINCLUDE works identically to INCLUDE 
with the exception that XINCLUDE'd files are only ever included once. For 
example, if a program has 2 XINCLUDE statements with the same filename, only 
the first XINCLUDE will have any effect.

INCDIR may be used to specify a path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation problems.


@ENDNODE XINCLUDE

@NODE INCLUDE "SYSTEM1"

@{fg shine}Statement: INCLUDE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : INCLUDE Filename

INCLUDE is a compile time directive which causes the specified file, 
Filename, to be compiled as part of the programs object code. The file must 
be in tokenised form (ie: saved from the Blitz 2 editor) - ascii files may 
not be INCLUDE'd.

INCDIR may be used to specify a path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation problems.



@ENDNODE INCLUDE

@NODE Jimi  "SYSTEM1"

@{fg shine}Statement: Jimi @{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Jimi  



@ENDNODE Jimi 

@NODE SHARED "SYSTEM1"

@{fg shine}Statement: SHARED@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : SHARED Var[,Var...]

Shared is used to declare certain variables within a procedure definition as 
being global variables. Any variables appearing within a procedure 
definition that do not appear in a Shared statement are, by default, local 
variables.


@ENDNODE SHARED

@NODE For "SYSTEM1"

@{fg shine}Statement: For@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : For Var=Expression1 To Expression2 [Step Expression3]

The For statement initializes a For...Next loop. All For/Next loops must 
begin with a For statement, and must have a terminating Next statement 
further down the program. For/Next loops cause a particular section of code 
to be repeated a certain number of times. The For statement does most of the 
work in a For/Next loop. When For is executed, the variable specified by Var 
(known as the index variable) will be set to the value Expression1. After 
this, the actual loop commences.

At the beginning of the loop, a check is made to see if the value of Var has 
exceeded Expression2. If so, program flow will branch to the command 
following the For/Next loop's Next, ending the loop. If not, program flow 
continues on until the loop's Next is reached. At this point, the value 
specified in Expression3 (the 'step' value) is added to Var, and program 
flow is sent back to the top of the loop, where Var is again checked against 
Expression2. If Expression3 is omitted, a default step value of 1 will be 
used.

An interesting feature of For/Next loops is the ability to use the loop's 
index variable within the loop.
In order for a For/Next loop to count 'down' from one value to a lower 
value, a negative step number must be supplied.


@ENDNODE For

@NODE Next "SYSTEM1"

@{fg shine}Statement: Next@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Next [Var[,Var...]]

Next terminates a For/Next loop. Please refer to the For command for more 
information on For/Next loops.


@ENDNODE Next

@NODE To "SYSTEM1"

@{fg shine}Statement: To@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : To Expression2 [Step Expression3]



@ENDNODE To

@NODE Step "SYSTEM1"

@{fg shine}Statement: Step@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Step increment



@ENDNODE Step

@NODE Data "SYSTEM1"

@{fg shine}Statement: Data@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Data [.Type] Item[,Item...]

The Data statement allows you to include pre-defined values in your 
programs. These 'data items' may be transferred into variables using the 
Read statement.
When data is read into variables, the Type of the data being read MUST match 
the type of the variable it is being read into.





@ENDNODE Data

@NODE Read "SYSTEM1"

@{fg shine}Statement: Read@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Read Var[,Var...]

Read is used to transfer items in Data statements into variables. Data is 
transferred sequentially into variables through what is known as a 'data 
pointer'. Each time a pice of data is read, the data pointer is incremented 
to point at the next piece of data. The data pointer may be set to point to 
a particular piece of data using the Restore command.


@ENDNODE Read

@NODE CNIF "SYSTEM1"

@{fg shine}Statement: CNIF@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CNIF Constant Comparison Constant

CNIF allows you to conditionally compile a section of program code based on 
a comparison of 2 constants. Comparison should be one of '<', '>', '=', 
'<>', '<=' or '>='. If the comparison proves to be true, then compiling will 
continue as normal. If the comparison proves to be false, then no object 
code will be generated until a matching CEND is encountered.

Please refer to the Programming chapter of the Blitz 2 Programmers Guide for 
more information on conditional compiling.
 

@ENDNODE CNIF

@NODE CSIF "SYSTEM1"

@{fg shine}Statement: CSIF@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CSIF "String" Comparison "String"

CSIF allows you to conditionally compile a section of program code based on 
a comparison of 2 literal strings. Comparison should be one of '<', '>', 
'=', '<>', '<=' or '>='. Both strings must be quote enclosed literal 
strings. If the comparison proves to be true, then compiling will continue 
as normal. If the comparison proves to be false, then no object code will be 
generated until a matching CEND is encountered.

CSIF is of most use in macros for checking macro parameters.

Please refer to the Programming chapter of the Blitz 2 Programmers Guide for 
more information on conditional compiling.


@ENDNODE CSIF

@NODE CELSE "SYSTEM1"

@{fg shine}Statement: CELSE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CELSE 

CELSE may be used between a CNIF or CSIF, and a CEND to cause code to be 
compiled when a constant comparison proves to be false. 

Please refer to the Programming chapter of the Blitz 2 Programmers Guide for 
more information on conditional compiling.


@ENDNODE CELSE

@NODE CEND "SYSTEM1"

@{fg shine}Statement: CEND@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CEND 

CEND marks the end of a block of conditionally compiled code. CEND must 
always appear somewhere following a CNIF or CSIF directive.

Please refer to the Programming chapter of the Blitz 2 Programmers Guide for 
more information on conditional compiling.


@ENDNODE CEND

@NODE CERR "SYSTEM1"

@{fg shine}Statement: CERR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CERR Errormessage

CERR allows a program to generate compile-time error messages. CERR is 
normally used in conjunction with macros and conditional compiling to 
generate errors when incorrect macro parameters are encountered.

Please refer to the Programming chapter of the Blitz 2 Programmers Guide for 
more information on conditional compiling.



@ENDNODE CERR

@NODE Then "SYSTEM1"

@{fg shine}Statement: Then@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Then Statement...



@ENDNODE Then

@NODE Else "SYSTEM1"

@{fg shine}Statement: Else@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Else [Statement...]

Else may be used after an If to cause program instructions to be executed if 
the expression specified in the If proved to be false.


@ENDNODE Else

@NODE Jimi  "SYSTEM1"

@{fg shine}Statement: Jimi @{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Jimi  



@ENDNODE Jimi 

@NODE Jimi  "SYSTEM1"

@{fg shine}Statement: Jimi @{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Jimi  



@ENDNODE Jimi 

@NODE Dc "SYSTEM1"

@{fg shine}Statement: Dc@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Dc [.Size] Data[,Data...]



@ENDNODE Dc

@NODE Ds "SYSTEM1"

@{fg shine}Statement: Ds@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Ds [.Size] Length



@ENDNODE Ds

@NODE Even "SYSTEM1"

@{fg shine}Statement: Even@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Even 

EVEN allows you to word align Blitz 2's internal program counter. This may 
be necessary if a DC, DCB or DS statement has caused the program counter to 
be left at an odd address.



@ENDNODE Even

@NODE Dcb "SYSTEM1"

@{fg shine}Statement: Dcb@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Dcb [.Size] Repeats,Data

DCB stand for 'define constant block'. DCB allows you to insert a repeating 
series of the same value into your assembler programs.




@ENDNODE Dcb

@NODE GetReg "SYSTEM1"

@{fg shine}Statement: GetReg@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : GetReg 68000 Reg,Expression

GetReg allows you to transfer the result of a BASIC expression to a 68000 
register. The result of the expression will first be converted into a long 
value before being moved to the data register.

GetReg should only be used to transfer expressions to one of the 8 data 
registers (d0-d7).

GetReg will use the stack to temporarily store any registers used in 
calculation of the expression.



@ENDNODE GetReg

@NODE IncBin "SYSTEM1"

@{fg shine}Statement: IncBin@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : IncBin Filename

INCBIN allows you to include a binary file in your object code. This is 
mainly of use to assembler language programmers, as having big chunks of 
binary data in the middle of a BASIC program is not really a good idea.

INCDIR may be used to specify an AmigaDos path for Filename.

Filename may be optionally quote enclosed to avoid tokenisation problems.












@ENDNODE IncBin

@NODE Free "SYSTEM1"

@{fg shine}Statement: Free@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Free Objectname Object#

Free is used to free a Blitz 2 object. Any memory consumed by the object's 
existance will be free'd up, and in the case of things such as windows and 
screens, the display may be altered. 
Attempting to free a non-existant object will have no effect.


@ENDNODE Free

@NODE Use "SYSTEM1"

@{fg shine}Statement: Use@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Use Objectname Object#

Use will cause the Blitz 2 object specified by Objectname and Object# to 
become the currently used object.


@ENDNODE Use

@NODE Stop "SYSTEM1"

@{fg shine}Statement: Stop@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Stop 

The Stop command will cause program flow to stop, and user control to be 
transferred to Blitz 2 direct mode.

The Stop command is really only useful in debugging situations, as it allows 
the programmer a chance to have a look at program variables via Blitz 2's 
direct mode.


@ENDNODE Stop

@NODE Cont "SYSTEM1"

@{fg shine}Statement: Cont@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Cont [N]

The Cont command is only available in Blitz 2 direct mode. Cont will cause 
program flow to continue from the instruction following the instruction 
which caused a jump to direct mode. This instruction may have been either a 
Stop or a program error of some kind.

The optional N parameter can be used to tell Blitz 2 programs to ignore a 
number of Stop commands after a Cont. This is useful in debugging as it 
allows you to insert a Stop inside a program loop, but not have to Cont 
every pass of the loop.


@ENDNODE Cont

@NODE SizeOf "SYSTEM1"

@{fg shine}Statement: SizeOf@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : SizeOf .Typename[,Entrypath]

SizeOf allows you to determine the amount of memory, in bytes, a particular 
variable type takes up. SizeOf may also be followed by an optional 
Entrypath, in which case the offset from the start of the type to the 
specified entry is returned.


@ENDNODE SizeOf

@NODE SetInt "SYSTEM1"

@{fg shine}Statement: SetInt@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : SetInt Type

SetInt is used to declare a section of program code as 'interupt' code. 
Before going further into the details of SetInt, let's have a quick look at 
what interupts are.

Often, when a computer program is running, an event of some importance takes 
place which must be processed immediately. This is done through interupts. 
When an interupt occurs, whatever program may be currently running is 
completely halted by the 68000. Then, a program known as an 'interupt 
handler' is started. Once the interupt handler has done it's work, the 
program which was originally interupted is restarted, without any knowledge 
of having been disturbed.

So what can cause an interupt? On the Amiga, there are 14 different types of 
possible interupts, each assigned it's own special number. These interupts 
are as follows:













InteruptCause of Interupt

0Serial transmit buffer empty
1Disk Block read/written
2Software interupt
3Cia ports interupt
4Co-processor ('copper') interupt
5Vetical Blank
6Blitter finished
7Audio channel 0 pointer/length fetched
8Audio channel 1 pointer/length fetched
9Audio channel 2 pointer/length fetched
10Audio channel 3 pointer/length fetched
11Serial receive buffer full
12Floppy disk sync
13External interupt


The most useful of these interupts is the vertical blank interupt. This 
interupt occurs every time an entire video frame has been fully displayed 
(about every sixtieth of a second), and is very useful for animation 
purposes. If a section of program code has been designated as a vertical 
blank interupt handler, then that section of code will be executed every 
sixtieth of a second.

Interupt handlers must perform their task as quickly as possible, especially 
in the case of vertical blank handlers which must NEVER take longer than one 
sixtieth of a second to execute.

Interupt handlers in Blitz 2 must NEVER access string variables or literal 
strings. In Blitz mode, this is the only restriction on interupt handlers. 
In Amiga mode, no blitter, Intuition or file i/o commands may be executed by 
interupt handlers.

To set up a section of code to be used as an interupt handler, you use the 
SetInt command followed by the actual interupt handler code. An End SetInt 
should follow the interupt code. The Type parameter specifies the type of 
interupt, from the above table, the interupt handler should be attached to. 
For example, SetInt 5 should be used for vertical blank interupt code.

More than one interupt handler may be attached to a particular type of 
interupt.


@ENDNODE SetInt

@NODE ClrInt "SYSTEM1"

@{fg shine}Statement: ClrInt@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ClrInt Type

ClrInt may be used to remove any interupt handlers currently attached to the 
specified interupt Type. The SetInt command is used to attached interupt 
handlers to particular interupts.


@ENDNODE ClrInt

@NODE MaxLen "SYSTEM1"

@{fg shine}Statement: MaxLen@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : MaxLen StringVar=Expression

MaxLen sets aside a block of memory for a string variable to grow into. This 
is normally only necessary in the case of special Blitz 2 commands which 
require this space to be present before execution. Currently, only 2 Blitz 2 
commands require the use of MaxLen - FileRequest$ and Fields.

Example

; 
; filerequest program example 
; 

WbToScreen 0      ;pick up workbench as currently used screen 
WBenchToFront_     ;bring workbench to front of view 
MaxLen pa$=160     ;these are necessary for FileRequest$...
MaxLen fi$=64      ;to operate properly! 


a$=FileRequest$("Select a File",pa$,fi$) ;bring up a file requester

WBenchToBack_      ;workbench back to rear of view.


@ENDNODE MaxLen

@NODE DEFTYPE "SYSTEM1"

@{fg shine}Statement: DEFTYPE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DEFTYPE .Typename [Var[,Var...]]

DEFTYPE may be used to declare a list of variables as being of a particular 
type. In this case, Var parameters must be supplied.

DEFTYPE may be used to select a default variable type for future 'unknown' 
variables. Unknown variables are variables created with no Typename 
specifier. In this case, no Var parameters are supplied.

Please refer to the Programming chapter of the Blitz 2 Programmers guide for 
more information on variable types and the use of DEFTYPE.


@ENDNODE DEFTYPE

@NODE BLITZ "SYSTEM1"

@{fg shine}Statement: BLITZ@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLITZ 

The BLITZ directive is used to enter Blitz mode. For a full discussion on 
Amiga/Blitz mode, please refer to the programming chapter of the Blitz 2 
Programmers Guide.


@ENDNODE BLITZ

@NODE AMIGA "SYSTEM1"

@{fg shine}Statement: AMIGA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : AMIGA 

The AMIGA directive is used to enter Amiga mode. For a full discussion on 
Amiga/Blitz mode, please refer to the programming chapter of the Blitz 2 
Programmers Guide.


@ENDNODE AMIGA

@NODE QAMIGA "SYSTEM1"

@{fg shine}Statement: QAMIGA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : QAMIGA 

The QAMIGA directive is used to enter Quick Amiga mode. For a full 
discussion on Amiga/Blitz mode, please refer to the programming chapter of 
the Blitz 2 Programmers Guide.


@ENDNODE QAMIGA

@NODE VWait "SYSTEM1"

@{fg shine}Statement: VWait@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : VWait [Frames]

VWait will cause program flow to halt until the next vertical blank occurs. 
The optional Frames parameter may be used to wait for a particular number of 
vertical blanks.

VWait is especially useful in animation for synchronizing display changes 
with the rate at which the display is physically redrawn by the monitor.


@ENDNODE VWait

@NODE ALibJsr "SYSTEM1"

@{fg shine}Statement: ALibJsr@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ALibJsr Token[,Form]

ALibJsr is only used when writing Blitz 2 libraries. ALibJsr allows you to 
call a routine from another library from within your own library. Please 
refer to the Library Writing section of the programmers guide for more 
information on library writing.



@ENDNODE ALibJsr

@NODE TokeJsr "SYSTEM1"

@{fg shine}Statement: TokeJsr@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : TokeJsr Token[,Form]

TokeJsr allows you to call any of Blitz 2's library based routines. Token 
refers to either a token number, or an actual token name. Form refers to a 
particular form of the token. A full list of all token numbers with their 
various forms will be available shortly from Acid Software.



@ENDNODE TokeJsr

@NODE BLibJsr "SYSTEM1"

@{fg shine}Statement: BLibJsr@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLibJsr Token[,Form]

BLibJsr is only used when writing Blitz 2 libraries. BLibJsr allows you to 
call a routine from another library from within your own library. Please 
refer to the Library Writing section of the programmers guide for more 
information on library writing.


@ENDNODE BLibJsr

@NODE Jimi  "SYSTEM1"

@{fg shine}Statement: Jimi @{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : Jimi  



@ENDNODE Jimi 

@NODE ABCD "SYSTEM1"

@{fg shine}Statement: ABCD@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ABCD 



@ENDNODE ABCD

@NODE ADD "SYSTEM1"

@{fg shine}Statement: ADD@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADD 



@ENDNODE ADD

@NODE ADDI "SYSTEM1"

@{fg shine}Statement: ADDI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADDI 



@ENDNODE ADDI

@NODE ADDA "SYSTEM1"

@{fg shine}Statement: ADDA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADDA 



@ENDNODE ADDA

@NODE ADDQ "SYSTEM1"

@{fg shine}Statement: ADDQ@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADDQ 



@ENDNODE ADDQ

@NODE ADDX "SYSTEM1"

@{fg shine}Statement: ADDX@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ADDX 



@ENDNODE ADDX

@NODE AND "SYSTEM1"

@{fg shine}Statement: AND@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : AND 



@ENDNODE AND

@NODE ANDI "SYSTEM1"

@{fg shine}Statement: ANDI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ANDI 



@ENDNODE ANDI

@NODE ASL "SYSTEM1"

@{fg shine}Statement: ASL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ASL 



@ENDNODE ASL

@NODE ASR "SYSTEM1"

@{fg shine}Statement: ASR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ASR 



@ENDNODE ASR

@NODE BCC "SYSTEM1"

@{fg shine}Statement: BCC@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BCC 



@ENDNODE BCC

@NODE BCS "SYSTEM1"

@{fg shine}Statement: BCS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BCS 



@ENDNODE BCS

@NODE BEQ "SYSTEM1"

@{fg shine}Statement: BEQ@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BEQ 



@ENDNODE BEQ

@NODE BGE "SYSTEM1"

@{fg shine}Statement: BGE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BGE 



@ENDNODE BGE

@NODE BGT "SYSTEM1"

@{fg shine}Statement: BGT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BGT 



@ENDNODE BGT

@NODE BHI "SYSTEM1"

@{fg shine}Statement: BHI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BHI 



@ENDNODE BHI

@NODE BLE "SYSTEM1"

@{fg shine}Statement: BLE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLE 



@ENDNODE BLE

@NODE BLS "SYSTEM1"

@{fg shine}Statement: BLS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLS 



@ENDNODE BLS

@NODE BLT "SYSTEM1"

@{fg shine}Statement: BLT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BLT 



@ENDNODE BLT

@NODE BMI "SYSTEM1"

@{fg shine}Statement: BMI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BMI 



@ENDNODE BMI

@NODE BNE "SYSTEM1"

@{fg shine}Statement: BNE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BNE 



@ENDNODE BNE

@NODE BPL "SYSTEM1"

@{fg shine}Statement: BPL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BPL 



@ENDNODE BPL

@NODE BVC "SYSTEM1"

@{fg shine}Statement: BVC@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BVC 



@ENDNODE BVC

@NODE BVS "SYSTEM1"

@{fg shine}Statement: BVS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BVS 



@ENDNODE BVS

@NODE BCHG "SYSTEM1"

@{fg shine}Statement: BCHG@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BCHG 



@ENDNODE BCHG

@NODE BCLR "SYSTEM1"

@{fg shine}Statement: BCLR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BCLR 



@ENDNODE BCLR

@NODE BSET "SYSTEM1"

@{fg shine}Statement: BSET@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BSET 



@ENDNODE BSET

@NODE BTST "SYSTEM1"

@{fg shine}Statement: BTST@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BTST 



@ENDNODE BTST

@NODE BRA "SYSTEM1"

@{fg shine}Statement: BRA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BRA 



@ENDNODE BRA

@NODE BSR "SYSTEM1"

@{fg shine}Statement: BSR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : BSR 



@ENDNODE BSR

@NODE CHK "SYSTEM1"

@{fg shine}Statement: CHK@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CHK 



@ENDNODE CHK

@NODE CLR "SYSTEM1"

@{fg shine}Statement: CLR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CLR 



@ENDNODE CLR

@NODE CMP "SYSTEM1"

@{fg shine}Statement: CMP@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CMP 



@ENDNODE CMP

@NODE CMPI "SYSTEM1"

@{fg shine}Statement: CMPI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CMPI 



@ENDNODE CMPI

@NODE CMPA "SYSTEM1"

@{fg shine}Statement: CMPA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CMPA 



@ENDNODE CMPA

@NODE CMPM "SYSTEM1"

@{fg shine}Statement: CMPM@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : CMPM 



@ENDNODE CMPM

@NODE DBCC "SYSTEM1"

@{fg shine}Statement: DBCC@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBCC 



@ENDNODE DBCC

@NODE DBCS "SYSTEM1"

@{fg shine}Statement: DBCS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBCS 



@ENDNODE DBCS

@NODE DBEQ "SYSTEM1"

@{fg shine}Statement: DBEQ@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBEQ 



@ENDNODE DBEQ

@NODE DBGE "SYSTEM1"

@{fg shine}Statement: DBGE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBGE 



@ENDNODE DBGE

@NODE DBGT "SYSTEM1"

@{fg shine}Statement: DBGT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBGT 



@ENDNODE DBGT

@NODE DBHI "SYSTEM1"

@{fg shine}Statement: DBHI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBHI 



@ENDNODE DBHI

@NODE DBLE "SYSTEM1"

@{fg shine}Statement: DBLE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBLE 



@ENDNODE DBLE

@NODE DBLS "SYSTEM1"

@{fg shine}Statement: DBLS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBLS 



@ENDNODE DBLS

@NODE DBLT "SYSTEM1"

@{fg shine}Statement: DBLT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBLT 



@ENDNODE DBLT

@NODE DBMI "SYSTEM1"

@{fg shine}Statement: DBMI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBMI 



@ENDNODE DBMI

@NODE DBNE "SYSTEM1"

@{fg shine}Statement: DBNE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBNE 



@ENDNODE DBNE

@NODE DBPL "SYSTEM1"

@{fg shine}Statement: DBPL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBPL 



@ENDNODE DBPL

@NODE DBVC "SYSTEM1"

@{fg shine}Statement: DBVC@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBVC 



@ENDNODE DBVC

@NODE DBVS "SYSTEM1"

@{fg shine}Statement: DBVS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBVS 



@ENDNODE DBVS

@NODE DBF "SYSTEM1"

@{fg shine}Statement: DBF@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBF 



@ENDNODE DBF

@NODE dra "SYSTEM1"

@{fg shine}Statement: dra@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : dra 



@ENDNODE dra

@NODE DBT "SYSTEM1"

@{fg shine}Statement: DBT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DBT 



@ENDNODE DBT

@NODE DIVS "SYSTEM1"

@{fg shine}Statement: DIVS@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DIVS 



@ENDNODE DIVS

@NODE DIVU "SYSTEM1"

@{fg shine}Statement: DIVU@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : DIVU 



@ENDNODE DIVU

@NODE EOR "SYSTEM1"

@{fg shine}Statement: EOR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : EOR 



@ENDNODE EOR

@NODE EORI "SYSTEM1"

@{fg shine}Statement: EORI@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : EORI 



@ENDNODE EORI

@NODE EXG "SYSTEM1"

@{fg shine}Statement: EXG@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : EXG 



@ENDNODE EXG

@NODE EXT "SYSTEM1"

@{fg shine}Statement: EXT@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : EXT 



@ENDNODE EXT

@NODE ILLEGAL "SYSTEM1"

@{fg shine}Statement: ILLEGAL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : ILLEGAL 



@ENDNODE ILLEGAL

@NODE JMP "SYSTEM1"

@{fg shine}Statement: JMP@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : JMP 



@ENDNODE JMP

@NODE JSR "SYSTEM1"

@{fg shine}Statement: JSR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : JSR 



@ENDNODE JSR

@NODE LEA "SYSTEM1"

@{fg shine}Statement: LEA@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : LEA 



@ENDNODE LEA

@NODE LINK "SYSTEM1"

@{fg shine}Statement: LINK@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : LINK 



@ENDNODE LINK

@NODE LSL "SYSTEM1"

@{fg shine}Statement: LSL@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : LSL 



@ENDNODE LSL

@NODE LSR "SYSTEM1"

@{fg shine}Statement: LSR@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : LSR 



@ENDNODE LSR

@NODE MOVE "SYSTEM1"

@{fg shine}Statement: MOVE@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : MOVE 



@ENDNODE MOVE

@NODE MOVEP "SYSTEM1"

@{fg shine}Statement: MOVEP@{fg text}
--------------------------------------------------------------------------------
Modes  : 
Syntax : MOVEP 
@ENDNODE MOVEP

@NODE MAIN "SYSTEM1"

.-----------------------------------------------------------------------------.
|                                  @{b}SYSTEM1@{ub}                                    |
`-----------------------------------------------------------------------------'

                             @{"     Overview     " link OVERVIEW}

                               Command Index                                

                 @{" AsmExit    " link AsmExit}                @{" Case       " link Case}
                 @{" CELSE      " link CELSE}                @{" CEND       " link CEND}
                 @{" CERR       " link CERR}                @{" ClrInt     " link ClrInt}
                 @{" CNIF       " link CNIF}                @{" Cont       " link Cont}
                 @{" CSIF       " link CSIF}                @{" Data       " link Data}
                 @{" Dc         " link Dc}                @{" Dcb        " link Dcb}
                 @{" Default    " link Default}                @{" Dim        " link Dim}
                 @{" Ds         " link Ds}                @{" Else       " link Else}
                 @{" End        " link End}                @{" Even       " link Even}
                 @{" For        " link For}                @{" Free       " link Free}
                 @{" GetReg     " link GetReg}                @{" Gosub      " link Gosub}
                 @{" Goto       " link Goto}                @{" If         " link If}
                 @{" IncBin     " link IncBin}                @{" INCLUDE    " link INCLUDE}
                 @{" Jimi       " link Jimi }                @{" Jimi       " link Jimi }
                 @{" Jimi       " link Jimi }                @{" Let        " link Let}
                 @{" Macro      " link Macro}                @{" MaxLen     " link MaxLen}
                 @{" MouseWait  " link MouseWait}                @{" MOVEP      " link MOVEP}
                 @{" NEWTYPE    " link NEWTYPE}                @{" Next       " link Next}
                 @{" Read       " link Read}                @{" Return     " link Return}
                 @{" Select     " link Select}                @{" SetInt     " link SetInt}
                 @{" SHARED     " link SHARED}                @{" SizeOf     " link SizeOf}
                 @{" Statement  " link Statement}                @{" Step       " link Step}
                 @{" Stop       " link Stop}                @{" Then       " link Then}
                 @{" To         " link To}                @{" Use        " link Use}
                 @{" While      " link While}                @{" XINCLUDE   " link XINCLUDE}
@ENDNODE MAIN

